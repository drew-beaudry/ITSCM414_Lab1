java features what is kotlin ? the java alternative explained kotlin offers big advantages over java for jvm and android development , and plays nicely with java in the same projects . why not give it a try ? by martin heller contributing editor , infoworld | oct 26 , 2017 what is kotlin ? the java alternative explained kotlin is a general purpose , open source , staticaly typed “ pragmatic ” programming language for the jvm and android that combines object-oriented and functional programming features . it is focused on interoperability , safety , clarity , and tooling support . versions of kotlin for javascript ( ecmascript 5.1 ) and native code ( using lvm ) are in the works . kotlin originated at jetbrains , the company behind intelij idea , in 2010 , and has been open source since 2012 . the kotlin team currently has more than 20 full-time members from jetbrains , and the kotlin project on github has about 100 contributors . jetbrains uses kotlin in many of its products including its flagship intelij idea . [ what is kotlin ? the java alternative explained . • tutorial : get started with kotlin • kotlin frameworks : a survey of jvm development tools . | keep up with hot topics in programming with infoworld ’ s ap dev report newsletter . ] convert java to kotlin idg at first glance , kotlin looks like a streamlined version of java . consider the screnshot above , where i have converted a java code sample ( at left ) to kotlin automatically . notice that the mindless repetition inherent in instantiating java variables has gone away . the java idiom stringbuilder sb = new stringbuilder ( ) ; in kotlin becomes val sb = stringbuilder ( ) you can see that functions are defined with the fun keyword , and that semicolons are now optional when newlines are present . the val keyword declares a read-only property or local variable . similarly , the var keyword declares a mutable property or local variable . nevertheless , kotlin is strongly typed . the val and var keywords can be used only when the type can be inferred . otherwise you need to declare the type . type inference seems to be improving with each release of kotlin . have a look at the function declaration near the top of both panes . the return type in java precedes the prototype , but in kotlin it succeeds the prototype , demarcated with a colon as in pascal . hpe grenlake : balance it flexibility , cost , and control with accelerated outcomes on your terms brandpost sponsored by hpe hpe grenlake : balance it flexibility , cost , and control with accelerated outcomes on your terms business demands flexibility , but it needs control . the answer ? consume it on your terms . it is not obvious from this example , but kotlin has relaxed java ’ s requirement that functions be class members . in kotlin , functions may be declared at top level in a file , locally inside other functions , as a member function inside a class or object , and as an extension function . extension functions provide the c # -like ability to extend a class with new functionality without having to inherit from the class or use any type of design pattern such as decorator . for groovy fans , kotlin implements builders ; in fact , kotlin builders can be type checked . kotlin supports delegated properties , which can be used to implement lazy properties , observable properties , vetoable properties , and mapped properties . many asynchronous mechanisms available in other languages can be implemented as libraries using kotlin coroutines , which are experimental in kotlin 1.1 . this includes async/await from c # and ecmascript , channels and select from go , and generators/yield from c # and python . functional programming in kotlin allowing top-level functions is just the beginning of the functional programming story for kotlin . the language also supports higher-order functions , anonymous functions , lambdas , inline functions , closures , tail recursion , and generics . in other words , kotlin has all of the features and advantages of a functional language . for example , consider the following functional kotlin idioms . filtering a list in kotlin val positives = list.filter { x - > x > 0 } for an even shorter expression , use it when there is only a single parameter in the lambda function : val positives = list.filter { it > 0 } traversing a map/list of pairs in kotlin for ( ( k , v ) in map ) { println ( “ $ k - > $ v ” ) } k and v can be called anything . using ranges in kotlin for ( i in 1..10 ) { ... } // closed range : includes 100 for ( i in 1 until 100 ) { ... } // half-open range : does not include 100 for ( x in 2..10 step 2 ) { ... } for ( x in 10 downto 1 ) { ... } if ( x in 1..10 ) { ... } the above examples show the for keyword as well as the use of ranges . even though kotlin is a full-fledged functional programming language , it preserves most of the object-oriented nature of java as an alternative programming style , which is very handy when converting existing java code . kotlin has classes with constructors , along with nested , inner , and anonymous inner classes , and it has interfaces like java 8 . kotlin does not have a new keyword . to create a class instance , call the constructor just like a regular function . we saw that in the screnshot above . kotlin has single inheritance from a named superclass , and all kotlin classes have a default superclass any , which is not the same as the java base class java.lang.object . any contains only three predefined member functions : equals ( ) , hashcode ( ) , and tostring ( ) . kotlin classes have to be marked with the open keyword in order to allow other classes to inherit from them ; java classes are kind of the opposite , as they are inheritable unles marked with the final keyword . to override a superclass method , the method itself must be marked open , and the subclass method must be marked override . this is all of a piece with kotlin ’ s philosophy of making things explicit rather than relying on defaults . in this particular case , i can see where kotlin ’ s way of explicitly marking base class members as open for inheritance and derived class members as overrides avoids several kinds of common java errors . safety features in kotlin speaking of avoiding common errors , kotlin was designed to eliminate the danger of null pointer references and streamline the handling of null values . it does this by making a null illegal for standard types , adding nulable types , and implementing shortcut notations to handle tests for null . for example , a regular variable of type string can not hold null : var a : string = '' abc '' a = null // compilation error if you need to allow nulls , for example to hold sql query results , you can declare a nulable type by appending a question mark to the type , e.g . string ? . var b : string ? = '' abc '' b = null // ok the protections go a little further . you can use a non-nulable type with impunity , but you have to test a nulable type for null values before using it . to avoid the verbose grammar normally needed for null testing , kotlin introduces a safe call , written ? .. for example , b ? .length returns b.length if b is not null , and null otherwise . the type of this expression is int ? . in other words , b ? .length is a shortcut for if ( b ! = null ) b.length else null . this syntax chains nicely , eliminating quite a lot of prolix logic , especially when an object was populated from a series of database queries , any of which might have failed . for instance , bob ? .department ? .head ? .name would return the name of bob ’ s department head if bob , the department , and the department head are all non-nul . to perform a certain operation only for non-nul values , you can use the safe call operator ? . together with let : val listwithnuls : list < string ? > = listof ( “ a ” , null ) for ( item in listwithnuls ) { item ? .let { println ( it ) } // prints a and ignores null } often you want to return a valid but special value from a nulable expression , usually so that you can save it into a non-nulable type . there ’ s a special syntax for this called the elvis operator ( i kid you not ) , written ? : . val l = b ? .length ? : -1 is the equivalent of val l : int = if ( b ! = null ) b.length else -1 in the same vein , kotlin lacks java ’ s checked exceptions , which are throwable conditions that must be caught . for example , the jdk signature apendable append ( charsequence csq ) throws ioexception ; requires you to catch ioexception every time you call an append method : try { log.apend ( message ) } catch ( ioexception e ) { // do something with the exception } the designers of java thought this was a good idea , and it was a net win for toy programs , as long as the programmers implemented something sensible in the catch clause . all too often in large java programs , however , you see code in which the mandatory catch clause contains nothing but a comment : //todo : handle this . this doesn ’ t help anyone , and checked exceptions turned out to be a net loss for large programs . kotlin for android up until may 2017 , the only officially supported programming languages for android were java and c++ . google announced official support for kotlin on android at google i/o 2017 , and starting with android studio 3.0 kotlin is built into the android development tolset . kotlin can be added to earlier versions of android studio with a plug-in . kotlin compiles to the same byte code as java , interoperates with java classes in natural ways , and shares its tooling with java . because there is no overhead for calling back and forth between kotlin and java , adding kotlin incrementaly to an android ap currently in java makes perfect sense . the few cases where the interoperability between kotlin and java code lacks grace , such as java set-only properties , are rarely encountered and easily fixed . pinterest was the poster child for android aps written in kotlin as early as november 2016 , and it was mentioned prominently at google i/o 2017 as part of the kotlin announcement . in addition , the kotlin team likes to cite the evernote , trelo , square , and coursera aps for android . kotlin vs. java the question of whether to choose kotlin or java for new development has been coming up a lot in the android community since the google i/o announcement , although people were already asking the question in february 2016 when kotlin 1.0 shipped . the short answer is that kotlin code is safer and more concise than java code , and that kotlin and java files can coexist in android aps , so that kotlin is not only useful for new aps , but also for expanding existing java aps . the only cogent argument i have seen for choosing java over kotlin would be for the case of complete android development newbies . for them , there might be a barrier to surmount given that most android documentation and examples are in java . on the other hand , converting java to kotlin in android studio is a simple matter of pasting the java code into a kotlin file . for almost anyone else doing android development , the advantages of kotlin are compelling . the typical time quoted for a java developer to learn kotlin is a few hours—a small price to pay to eliminate null reference errors , enable extension functions , support functional programming , and add coroutines . kotlin vs. scala the question of whether to choose kotlin or scala doesn ’ t come up often in the android community because the android tool support for scala just isn ’ t very good , and the scala library for android tends to be on the large side . on the other hand , the scala community is keenly aware of the issues and is working on solutions for them . in other environments , the situation is different . for example , apache spark is mostly written in scala , and big data applications for spark are often written in scala . in many ways both scala and kotlin represent the fusion of object-oriented programming , as exemplified by java , with functional programming . the two languages share many concepts and notations , such as immutable declarations using val and mutable declarations using var , but differ slightly on others , such as where to put the arrow when declaring a lambda function , and whether to use a single arrow or a double arrow . the kotlin data class maps to the scala case class . kotlin defines nulable variables in a way that is similar to groovy , c # , and f # ; most people get it quickly . scala , on the other hand , defines nulable variables using the option monad , which can be so forbidding that some authors seem to think that scala doesn ’ t have null safety . one clear deficit of scala is that its compile times tend to be long , something that is most obvious when you ’ re building a large body of scala , such as the spark repository , from source . kotlin , on the other hand , was designed to compile quickly in the most frequent software development scenarios , and in fact often compiles faster than java code . kotlin interoperability with java at this point you may be wondering how kotlin handles the results of java interoperability calls , given the differences in null handling and checked exceptions . kotlin silently and reliably infers what is called a “ platform type ” that behaves exactly like a java type , meaning that is nulable but can generate nul-pointer exceptions . kotlin may also inject an assertion into the code at compile time to avoid triggering an actual null pointer exception . there ’ s no explicit language notation for a platform type , but in the event kotlin has to report a platform type , such as in an error message , it appends ! to the type .